# ColumbiaSHAPECode
A repository for the projects that me and Monica Shi created during our SHAPE summer program at Columbia University.
We took the Advanced Coding and Algorithms class under Professor Daniel Bauer for 3 weeks during the summer.

The OthelloAI is an AI player for the game Othello (also known as Reversi), utilizing the Minimax algorithm and Alpha-Beta Pruning to determine optimal moves. It first imports helper functions for gameplay essentials like retrieving possible moves, calculating scores, and simulating moves. A compute_utility function evaluates the board’s state, awarding extra points for occupying advantageous positions, such as the corners. The AI's strategy revolves around the Minimax algorithm, which simulates moves ahead to maximize its score and minimize the opponent's best responses. Specifically, minimax_max_node seeks to maximize the AI’s score, while minimax_min_node evaluates the opponent’s possible moves to minimize the AI’s score. To improve efficiency, the AI also uses Alpha-Beta Pruning, which optimizes Minimax by "pruning" branches of the decision tree that cannot affect the final decision, thus reducing the number of nodes evaluated and speeding up the process. This pruned version is implemented in alphabeta_max_node and alphabeta_min_node, and select_move_alphabeta leverages these functions for faster move selection. The main function, run_ai, manages the game loop by interacting with the game manager to receive board updates, compute the best move, and output it.

Search Algs code is an implementation of search algorithms to solve the n-Puzzle problem, using both basic and heuristic-based approaches. Utility functions include state_to_string for formatting the board, swap_cells to swap tiles and create a new board state, and get_successors to generate possible moves by shifting the blank tile (0) in four directions. The goal_test function verifies if a board state matches the goal configuration. The main search methods, Breadth-First Search (BFS) and Depth-First Search (DFS), are implemented in the bfs and dfs functions. BFS explores each state level by level to find the shortest solution, while DFS explores deeper paths first. Both use dictionaries to store previous states and moves, enabling solution reconstruction upon reaching the goal. A set of visited states prevents revisiting the same state, optimizing search efficiency. Two heuristics are implemented to evaluate board states: misplaced_heuristic and manhattan_heuristic. misplaced_heuristic counts tiles out of place, while manhattan_heuristic calculates the total Manhattan distance for each tile to its goal position. These heuristics allow the algorithm to prioritize states that are closer to the goal, enhancing search efficiency in more advanced algorithms like A*. The print_result function formats and displays the solution length, and the main block demonstrates both BFS and DFS on a sample puzzle. It also displays the Manhattan and Misplaced heuristic values, times each search method, and outputs the results, providing a basis for testing and comparing search strategies.
